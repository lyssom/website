{"version":3,"sources":["work.js"],"names":["Gear","x","y","fullRadius","angle","direction","speed","color","stroke","blur","arguments","length","undefined","_classCallCheck","this","canvas","document","createElement","radius","context","getContext","draw","width","height","filter","innerRadius","centerX","centerY","increment","fillStyle","beginPath","TWO_PI","slope_width","currentAngle","leftCornerAngle","leftTopCornerAngle","rightCornerAngle","rightTopCornerAngle","Math","cos","spoke_width","lineTo","closePath","GearField","Object","assign","gears","translate","gear","rotate","drawImage","g","dt","scrollDiff","_this","forEach","_this2","radii","dx","dy","drawGear","lastGear","gearCount","floor","random","overlap","attemptCount","nextGearAngle","newX","newY","sin","newAngle","findAnyOverlappingGear","addGear","MID_COLOR","LIGHT_COLOR","newGear","startX","startY","buildMeshFromGear","GEAR_SPEED","buildMesh","DARK_COLOR","a","b","colors","indexOf","gearFields","findOverlappingGear","getElementById","RENDER_WIDTH","RENDER_HEIGHT","PI","scale","lastUpdateTime","lastScrollPosition","window","scrollY","primaryGearCanvas","primaryGearContext","PRIMARY_GEAR_SIZE","requestAnimationFrame","animate","time","primaryGearContainer","primaryGearField","field","primaryGear","restore","QUAD_SIZE","setCanvasToWindowSize","save","getBoundingClientRect","_loop","box","quadY","find","f","quadX","primaryBox","masthead","scrollToCurrentHash","hash","location","matchingAnchor","querySelector","rect","top","headerRect","pageXOffset","targetOffset"],"mappings":"uVAAMA,G,KACJ,SAAAA,EAAYC,EAAGC,EAAGC,EAAYC,EAAOC,EAAWC,EAAOC,EAAOC,GAAmB,IAAXC,EAAWC,EAAA,EAAAA,UAAAC,QAAAC,KAAAA,IAAAF,UAAA,KAAAA,UAAA,GAAAG,EAAAC,KAAAd,CAAA,EAC/Ec,KAAKC,OAASC,SAASC,cAAc,QAAvB,EAEdH,KAAKI,OAASf,EAJZH,KAMGmB,QAAUL,KAAKC,OAAOK,WAAW,IAAvB,EALgEN,KAAXL,EAAWR,EAQ/Ea,KAAKZ,EAAIA,EAETY,KAAKV,MAAQA,EATbU,KAAKC,UAASC,EAWdF,KAAKR,MAAQA,EAEbQ,KAAKP,MAAQA,EATbO,KAAKK,OAALX,EAEAM,KAAKb,KAALQ,EAYAK,KAAKO,KAAL,CATA,C,yCAEAP,KAAKR,OAALgB,MAAA,EAAAR,KAAAI,OAWAJ,KAAKC,OAAOQ,OAAuB,EAAdT,KAAKI,OAR1BJ,KAAKN,OAWHM,KAAKK,QAAQK,OAAS,eAiBxB,IAxBA,IAAAC,EAAA,GAAAX,KAAAI,OAYMQ,EAAUZ,KAAKC,OAAOO,MAAQ,EAC9BK,EAAUb,KAAKC,OAAOQ,OAAS,EAKjCK,GAHJd,KAAKK,QAAQU,UAbRf,KAAAP,MACLO,KAAAK,QAAAW,UAAA,EAegBC,EAAS,IAInBC,EAfSR,EAAS,EAeU,EAE1BS,EAAe,EAAGA,EAAeF,EAAQE,GAAgBL,EAAW,CAZ5E,IAAMF,EAAUO,EAAhB,IAAAD,EACML,EAAsBJ,EAA5B,IAAAS,EAEAE,EAAAC,EAAA,GAAAH,EACAI,EAAAC,EAAA,GAAAL,EAEAlB,KAAIc,QAAAA,OAcAF,EAAUY,KAAKC,IAAIL,CAAT,EAA4BT,EAZ1CE,EAAMa,KAAAA,IAAcZ,CAAdY,EAANf,CAFA,EAIAX,KAAMkB,QAAAA,OAcFN,EAAUY,KAAKC,IAAIJ,CAAT,EAA+BrB,KAAKI,OAZlDS,EAAQM,KAAAA,IAAAA,CAAAA,EAAiCF,KAAzCb,MAFA,EAIEJ,KAAAK,QAAIkB,OAcFX,EAAUY,KAAKC,IAAIF,CAAT,EAAgCvB,KAAKI,OAZjDS,EAAIO,KAAAA,IAAAA,CAAAA,EAAkBC,KAAqBH,MAF3C,EAiBAlB,KAAKK,QAAQsB,OAZbf,EAAKP,KAAQsB,IAAbL,CAAKjB,EACgBe,EAGrBP,EAAKR,KAAQsB,IAAbL,CAAKjB,EACgBgB,CAOrB,CAAA,CAMFrB,KAAKK,QAAQuB,UAAb,EAAA5B,KAAAK,QAAKA,KAAL,EACAL,KAAKK,SACLL,KAAGK,QAAKX,YAAQM,KAAAN,OACdM,KAAAK,QAAKA,OAAL,EAED,C,UAGCwB,G,KACJ,SAAAA,EAAYxB,EAASlB,EAAGC,EAAGoB,EAAOC,GAAQV,EAAAC,KAAA6B,CAAA,EACxC7B,KAAKK,QAAUA,EAEfyB,OAAOC,OAAO/B,KAAM,CAACb,EAAAA,EAAGC,EAAAA,EAAGoB,MAAAA,EAAOC,OAAAA,CAAd,CAApB,EAHFT,KAAAgC,MAAA,EAA0C,C,2CACnC3B,GAQLL,KAAKK,QAAQ4B,UAAUC,EAAK/C,EAAG+C,EAAK9C,CAApC,EANA0C,KAAAA,QAAAK,OAAoBD,EAAC/C,KAArB2C,EAQA9B,KAAKK,QAAQ4B,UAAU,CAACC,EAAK9B,OAAQ,CAAC8B,EAAK9B,MAA3C,EANAJ,KAAKgC,QAAQI,UAAbF,EAAAjC,OAAA,EAAA,CAAA,EACDD,KAAAK,QAAA4B,UAAAC,EAAA9B,OAAA8B,EAAA9B,MAAA,EAQCJ,KAAKK,QAAQ8B,OAAO,CAACD,EAAK5C,KAA1B,EACAU,KAAKK,QAAQ4B,UAAU,CAACC,EAAK/C,EAAG,CAAC+C,EAAK9C,CAAtC,CACD,C,gCANCD,EAAKkB,EAAAA,EAAQ8B,EAAY7C,EAAzBE,EAAAC,GACA4C,EAAKhC,IAAAA,EAAQ4B,EAAAA,EAAAA,EAAgB7B,EAA7Bb,EAA2Ca,EAA3CX,CAAKY,EAEL,OADAL,KAAAgC,MAAK3B,KAAQ+B,CAAb,EACK/B,CACL,C,6BAEDiC,EAAAC,GAAA,IAAAC,EAAAxC,KAUCA,KAAKK,QAAQ4B,UAAUjC,KAAKb,EAAGa,KAAKZ,CAApC,EACAY,KAAKgC,MAAMS,QAAQ,SAAAP,GACjBA,EAAK5C,OAAS4C,EAAK1C,MAAQ+C,EATTjD,EAAOC,UAC3BiD,EAAIH,SAAQnD,CAAZ,CACA,CAMA,EALAc,KAAAK,QAAA4B,UAAA,CAAAjC,KAAAb,EAAA,CAAAa,KAAAZ,CAAA,CACD,C,4CAWmBD,EAAGC,EAAGgB,EAAQX,GAAO,IAAAiD,EAAA1C,KAWvC,OAVcA,KAAKgC,MAVZO,KAAAA,SAAAA,GAAY,IAIjBI,EAJiB,OAAAT,EAAAzC,QAAAA,IAEnBmD,EAAAF,EAAWD,EAAQP,EAAA/C,EAAAA,GAIN8C,GAHXC,EAAK5C,EAALF,EAAc8C,EAAK1C,EAAQ+C,GAGLM,GAFtBF,EAAKG,EAASZ,OAAd9B,GAEFuC,CACD,CAGe,CAWf,C,0CACiBI,GAPd,IANqC,IAAAC,EAAA,EAAAxB,KAAAyB,MAAA,EAAAzB,KAAA0B,OAAA,CAAA,EACvC9C,EAAI+C,EAAenB,OACjBvC,EAAGyC,EAAAzC,MAEF2D,EAAA,EAES,EAAVJ,GAAU,CACVI,CAAAA,GAgBA,IAAIC,EAAgB7B,KAAKyB,MAAsB,GAAhBzB,KAAK0B,OAAL,CAAX,EAAiCjC,EAAS,GAd9DqC,EAAQV,EAAYC,EAAKA,KAAMF,IAAAA,CAANE,EAAzBzC,EAAA,KARFmD,EAAAR,EAAA3D,EAAAoC,KAAAgC,IAAAH,CAAA,EAAAjD,EAAA,KAWDqD,EAAAV,EAAAzD,MAAA2B,EAAA,GAAA,EAyBG,GATGqC,EAAOtD,KAAKQ,OAAS+C,EAAOvD,KAAKS,QAAiB,EAAP6C,GAAmB,EAAPC,GAAY,CAACG,EAAuB1D,KAAKb,EAAImE,EAAMtD,KAAKZ,EAAImE,EAAe,GAATnD,EAAcX,CAAnE,IACrE2D,EAAe,EACfJ,CAAAA,GAhBJD,EAAIC,KAAYW,QAASV,EAAMzB,EAAK0B,EAALO,EAA/B,CAAA,EAAAV,EAAAxD,UAAAwD,EAAAvD,MAAAC,CAAIuD,EAkBGvD,IAAUmE,IAAapC,KAAK0B,OAAL,EAAgB,KAhB1C9C,EAAS2C,KAAS3C,QAAtB2C,EAAA5D,EAAA4D,EAAA3D,EAAA2D,EAAA3C,OAAA,EAAA2C,EAAAzD,MAAAyD,EAAAxD,UAAAwD,EAAAvD,MAAAqE,CAAad,EACTtD,KAAAA,kBAAJqE,CAAIrE,GAoBgB,GAAf2D,EAfHA,MAEA,CACA,C,kCAkBM3D,GAhBN,IAAAsE,EAAIN,KAAAA,OAAAA,EAAoBnE,KAATkB,MACfwD,EAAGV,KAAOJ,OAAPI,EAAqBC,KAAAA,OAEtBP,EAKCvD,IAAAoE,EACF,GALCd,IAAAA,EACGtD,IAFHuD,IAWHhD,KAAAiE,kBAFG,CAAA9E,EAAA4E,EAAA3E,EAAA4E,EAAA5D,OAAAA,EAAAd,MAAA,EAAAC,UAAA,EAAAC,MAAA0E,EAAAzE,MAAAA,CAAA,CAEH,CACF,C,mCAoBCO,KAAKmE,UAAUC,CAAf,EAlBApE,KAAAmE,UAAa3C,CAAb,EACAxB,KAAAmE,UAAa3C,CAAb,EAoBAxB,KAAKmE,UAAUP,CAAf,EAlBA5D,KAAAmE,UAAaN,CAAb,EAEEzD,KAAAA,MAAAA,KAAA,SAAAiE,EAAAC,GACD,OAAAC,EAAAC,QAAAH,EAAA5E,KAAA,EAAA8E,EAAAC,QAAAF,EAAA7E,KAAA,CAoBA,CArBCW,CAGF,C,UAsBJ,SAASsD,EAAuBvE,EAAGC,EAAGgB,EAAQX,GAlB1C,OAAAgF,EAAI1B,KAAY5D,SAAAA,GAAAA,OAAG4E,EAAJW,oBAAuBtE,EAAAA,EAAAA,EAAQd,CAA3ByE,CAAH5E,CAAhB,CAoBH,CAjBE,IAAAc,EAAAC,SAAAyE,eAAA,OAAA,EAqBCtE,EAAUJ,EAAOK,WAAW,IAAlB,EAlBVuD,EAAA,UACAD,EAAKO,UACLC,EAAKD,UAELI,EAAKJ,CAAAA,EAAUN,EAAfA,GAEAe,EAAA,KACEC,EAAcL,IAEjBvD,EAAA,EAAAO,KAAAsD,GAsBGZ,EAAa,KAEfa,EAAQ,EArBZN,EAASf,GACgBsB,EAAON,KAC/BO,EAAAC,OAAAC,QAEGlF,EAAkB0E,IAElBtE,EAAiBC,SAArBqE,eAAA,sBAAqBrE,EA0Bf8E,EAAoBlF,SAASyE,eAAe,cAAxB,EAxBpBd,EAANuB,EAAA9E,WAAA,IAAA,EACMsD,EAAN,IAAA/B,EAAAwD,EAAA,EAAA,EAAA,EAAA,CAAA,EACMjB,EAAa,IAAAlF,EAAnB,EAAA,EAAAoG,EAAA,EAAA,EAAA,CAAA,EAAApB,EAAAN,EAAAQ,EAAA,CAAA,CAAmB,EAEnB,SAAMG,EAAUH,GA0BdmB,sBAAsBC,CAAtB,EAKA,IAAIlD,EAAKmD,GAFPT,EA1BJ,OAAMH,EA0BeY,EAEHT,GAMZzC,GAJI,GAALD,IAxBDyC,EAAAA,IA4BeG,OAAOC,QAAUF,GAxBpCA,EAAqBC,OAArBC,QA4BoB,GAAf5C,GAAoB0C,EAAqB,MAxB1CK,EAAAA,UAAAA,EAAoB,EAAxBrF,EAAAO,MAAAP,EAAAQ,MAAI6E,EAEEI,EAAAA,KAAAA,EACAN,EAAAA,MAAAA,EAAoBlF,CAApBkF,EAEAO,EAAAA,QAAmB,SAAAC,GACnBC,EAAAA,KAAAA,EAActD,CAAdsD,CA0BD,CA3BCF,EAIJJ,EAAAA,OAAsBC,EAAtBtB,EA0BEkB,EAAkB5E,MAAQ8E,EAxB5BF,EAAGJ,OAAyBM,EAC1BN,EAAAA,EAAAA,EAAA,EACDa,EAAAzG,EAAAkG,EAAA,EACDK,EAAgBX,SAAAA,CAAhB,EAEA3E,EAAQyF,QAAR,GAIAd,EAAiBE,CA2BlB,CAvBoD,IAAAa,EAAA,IA2BrD,SAASC,IApBHJ,IAJFvF,IAAAA,EAAQ4F,SAARC,sBAAQD,EAwBqBE,GAvB7B9F,EAAAA,MAAA+F,EAAcrB,MA0BhB9E,EAAOQ,OAAS2F,EAAI3F,OAHW,SApB3BmF,GACD,IAmB4B,IArB7BS,EAAA,EAAAA,EAAApG,EAAAQ,OAAAsF,EAAAM,CAAAA,IAAAA,IA4BE,IAvBFjB,EAuBqBX,EAAW6B,KAAK,SAAAC,GAAA,OAAKA,EAAEpH,IAAMqH,EAAQT,GAAaQ,EAAEnH,IAAMiH,EAAQN,CAAlD,CAAhB,IAvBrBX,EAAAA,IAAAA,EAA0BE,EAAAA,EAA1BS,EAAAM,EAAAN,EAAAA,EAAAA,CAAAX,EACAA,EAAAA,KAAkB3E,CAAlB2E,EACAS,EAAAA,SAAAA,EAc6B,GArB7BQ,CAAA,CAqB6B,GApB3BT,EAAWtD,EAAIC,EAAAA,EAAf/B,MAAAuF,EAAAS,CAAAA,GAAAL,EAAAP,CAAA,EAWHa,EAAAf,EAAAQ,sBAAA,EA0BDZ,EAAoBmB,EAAWjG,MArBhCiE,EAAAhC,QAAA,SAAAmD,GAwBGA,EAAMrF,KAAK,EAAG,CAAd,CAtBJ,CAFC,EAID6E,EAASY,MAAAA,EACPZ,EAAUsB,OAASR,EACnBjG,EAAAd,EAAeiH,EAAf,EACAnG,EAAOQ,EAAS2F,EAAhB,EAH+BP,EAAAzF,OAAAkF,EAAA,EAAAO,EAAAtF,KAAA,EAOQoF,EAAK7C,SAAQ0D,CAAb,CAAA,CAD0B,SAAAG,IAO9D,IAGCF,EAHDG,EAAA1B,OAAA2B,SAAAD,KAb4BA,IAK+BE,EAAA5G,SAAA6G,cAAAH,CAAA,KA2CxDI,EAAOF,EAAeZ,sBAAf,EAhCTO,EAAaf,SAAAA,cAAqBQ,QAArBR,EAAqBQ,sBAArBR,EACjBJ,EAAoBmB,OAAAA,YAApBO,EAAAC,IAAAC,EAAAzG,OAEAgE,OAAAA,SAAAS,OAAmBiC,YAASC,CAA5B3C,EAEC,CAZKuB,EAAAA,EACAvB,OAAAA,iBAAgBpC,SAAhB2D,CAAAvB,EAEDc,sBAAAC,CAAA,EAWLJ,OAAAA,iBAAkB5E,OAAQ8E,CAA1BF,EACAA,OAAAA,iBAAkB3E,aAAS6E,CAA3BF","file":"work.js","sourcesContent":["class Gear {\n  constructor(x, y, fullRadius, angle, direction, speed, color, stroke, blur=true) {\n    this.canvas = document.createElement(\"canvas\");\n\n    this.radius = fullRadius;\n\n    this.context = this.canvas.getContext(\"2d\");\n\n    this.x = x;\n    this.y = y;\n\n    this.angle = angle;\n    this.direction = direction;\n    this.speed = speed;\n\n    this.color = color;\n    this.stroke = stroke;\n\n    this.blur = blur;\n\n    this.draw();\n  }\n  draw() {\n    this.canvas.width = this.radius * 2;\n    this.canvas.height = this.radius * 2;\n\n    if(this.blur) {\n      this.context.filter = \"blur(0.2em)\";\n    }\n\n    let innerRadius = this.radius * 0.8;\n    \n    const centerX = this.canvas.width / 2;\n    const centerY = this.canvas.height / 2;\n    \n    this.context.fillStyle = this.color;\n    this.context.beginPath();\n    \n    let increment = TWO_PI / 10;\n    \n    const spoke_width = increment / 2;\n    \n    const slope_width = spoke_width / 2;\n    \n    for(let currentAngle = 0; currentAngle < TWO_PI; currentAngle += increment) {\n      let leftTopCornerAngle = currentAngle - slope_width * 0.75;\n      let rightTopCornerAngle = currentAngle + slope_width * 0.75;\n      \n      let leftCornerAngle = leftTopCornerAngle - slope_width * 0.5;\n      let rightCornerAngle = rightTopCornerAngle + slope_width * 0.5;\n      \n      this.context.lineTo(\n        centerX + Math.cos(leftCornerAngle) * innerRadius,\n        centerY + Math.sin(leftCornerAngle) * innerRadius\n      );\n      this.context.lineTo(\n        centerX + Math.cos(leftTopCornerAngle) * this.radius,\n        centerY + Math.sin(leftTopCornerAngle) * this.radius\n      );\n      this.context.lineTo(\n        centerX + Math.cos(rightTopCornerAngle) * this.radius,\n        centerY + Math.sin(rightTopCornerAngle) * this.radius\n      );\n      this.context.lineTo(\n        centerX + Math.cos(rightCornerAngle) * innerRadius,\n        centerY + Math.sin(rightCornerAngle) * innerRadius\n      );\n    }\n    \n    this.context.closePath();\n    this.context.fill();\n    if(this.stroke) {\n      this.context.strokeStyle = this.stroke;\n      this.context.stroke();\n    }\n  }\n}\nclass GearField {\n  constructor(context, x, y, width, height) {\n    this.context = context;\n    \n    Object.assign(this, {x, y, width, height});\n    \n    this.gears = [];\n  }\n  \n  drawGear(gear) {\n    this.context.translate(gear.x, gear.y);\n    this.context.rotate(gear.angle);\n    this.context.translate(-gear.radius, -gear.radius);\n    this.context.drawImage(gear.canvas, 0, 0);\n    this.context.translate(gear.radius, gear.radius);\n    this.context.rotate(-gear.angle);\n    this.context.translate(-gear.x, -gear.y);\n  }\n\n  \n  addGear(x, y, radius, angle, direction, speed, color) {\n    let g = new Gear(x, y, radius, angle, direction, speed, color);\n    this.gears.push(g);\n    return g;\n  }\n  \n  draw(dt, scrollDiff) {\n    this.context.translate(this.x, this.y);\n    this.gears.forEach(gear => {\n      gear.angle += gear.speed * scrollDiff * gear.direction;\n      this.drawGear(gear);\n    });\n    this.context.translate(-this.x, -this.y);\n  }\n  \n  findOverlappingGear(x, y, radius, color) {\n    let overlap = this.gears.find(gear => {\n      if(gear.color !== color) {\n        return false;\n      }\n      let dx = (this.x + gear.x) - x;\n      let dy = (this.y + gear.y) - y;\n      let radii = gear.radius + radius;\n      \n      return (dx * dx) + (dy * dy) < radii * radii;\n    });\n    return overlap;\n  }\n  buildMeshFromGear(lastGear) {\n    let gearCount = 1 + Math.floor(Math.random() * 2);\n    \n    let radius = lastGear.radius;\n    let color = lastGear.color;\n    \n    let attemptCount = 0;\n    \n    while(gearCount > 0) {\n      attemptCount++;\n      let nextGearAngle = Math.floor(Math.random() * 10) * TWO_PI / 10;\n      let newX = lastGear.x + Math.cos(nextGearAngle) * radius * 1.85;\n      let newY = lastGear.y + Math.sin(nextGearAngle) * radius * 1.85;\n      \n      let newAngle = lastGear.angle + TWO_PI / 10 / 2;\n      if(newX < this.width && newY < this.height && newX > 0 && newY > 0 && !findAnyOverlappingGear(this.x + newX, this.y + newY, radius * 0.8, color)) {\n        attemptCount = 0;\n        gearCount--;\n        lastGear = this.addGear(newX, newY, radius, newAngle, lastGear.direction * -1, lastGear.speed, color);\n        if(color === MID_COLOR && Math.random() < 0.3) {\n          let newGear = this.addGear(lastGear.x, lastGear.y, lastGear.radius / 2, lastGear.angle, lastGear.direction, lastGear.speed, LIGHT_COLOR);\n          this.buildMeshFromGear(newGear);\n        }\n      }\n      if(attemptCount > 20) {\n        // bailing out\n        return;\n      }\n    } \n  }\n  buildMesh(color) {\n    let startX = Math.random() * this.width;\n    let startY = Math.random() * this.height;\n    \n    let radius = 150;\n    if(color === DARK_COLOR) {\n      radius = 200;\n    }\n    \n    if(color === LIGHT_COLOR) {\n      radius = 60;\n    }\n    \n    let lastGear = {x: startX, y: startY, radius, angle: 0, direction: 1, speed: GEAR_SPEED, color};\n    \n    this.buildMeshFromGear(lastGear)\n  }\n  \n  generate() {\n    this.buildMesh(DARK_COLOR);\n    this.buildMesh(DARK_COLOR);\n    this.buildMesh(MID_COLOR);\n    this.buildMesh(MID_COLOR);\n    this.buildMesh(LIGHT_COLOR);\n    \n    this.gears.sort((a, b) => {\n      return colors.indexOf(a.color) - colors.indexOf(b.color);\n    })\n  }\n}\n\nfunction findAnyOverlappingGear(x, y, radius, color) {\n  return gearFields.find(g => g.findOverlappingGear(x, y, radius, color));\n}\n\nlet canvas = document.getElementById(\"gears\");\n\nlet context = canvas.getContext(\"2d\");\n\nconst LIGHT_COLOR = \"#ffffff\";\nconst MID_COLOR = \"#ccece7\";\nconst DARK_COLOR = \"#25655a\";\n\nconst colors = [DARK_COLOR, MID_COLOR, LIGHT_COLOR];\n\nconst RENDER_WIDTH = 1500;\nconst RENDER_HEIGHT = 700;\n\nconst TWO_PI = Math.PI * 2;\n\nconst GEAR_SPEED = 0.0020;\n\nlet scale = 1;\n\nlet gearFields = [];\n\nlet lastUpdateTime = null;\n\nlet lastScrollPosition = window.scrollY;\n\nlet PRIMARY_GEAR_SIZE = 200;\n\nconst primaryGearContainer = document.getElementById(\"primaryGearContainer\");\nconst primaryGearCanvas = document.getElementById(\"primaryGears\");\nconst primaryGearContext = primaryGearCanvas.getContext(\"2d\");\nconst primaryGearField = new GearField(primaryGearContext, 0, 0, 0, 0);\nconst primaryGear = new Gear(0, 0, PRIMARY_GEAR_SIZE / 2, 0, -1, GEAR_SPEED, MID_COLOR, DARK_COLOR, false);\n\nfunction animate(time) {\n  requestAnimationFrame(animate);\n  \n  if(lastUpdateTime === null) {\n    lastUpdateTime = time;\n  }\n  let dt = time - lastUpdateTime;\n  \n  if(dt > 16) {\n    dt = 16;\n  }\n\n  let scrollDiff = window.scrollY - lastScrollPosition;\n  lastScrollPosition = window.scrollY;\n  \n  \n  if(scrollDiff !== 0 && lastScrollPosition < 460) { // don't re-render if unneeded\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    \n    context.save();\n    context.scale(scale, scale);\n\n    gearFields.forEach(field => {\n      field.draw(dt, scrollDiff);\n    });\n\n    primaryGear.angle += scrollDiff * GEAR_SPEED;\n    primaryGearCanvas.width = PRIMARY_GEAR_SIZE;\n    primaryGearCanvas.height = PRIMARY_GEAR_SIZE;\n    primaryGear.x = PRIMARY_GEAR_SIZE / 2;\n    primaryGear.y = PRIMARY_GEAR_SIZE / 2;\n    primaryGearField.drawGear(primaryGear);\n    \n    context.restore();\n  }\n  \n  \n  lastUpdateTime = time;\n\n}\n\nconst QUAD_SIZE = 600;\n\nfunction setCanvasToWindowSize() {\n  let box = masthead.getBoundingClientRect();\n  canvas.width = box.width;\n  canvas.height = box.height;\n  \n  for(let quadX = 0; quadX < canvas.width / QUAD_SIZE; quadX++) {\n    for(let quadY = 0; quadY < canvas.height / QUAD_SIZE; quadY++) {\n      let existingQuad = gearFields.find(f => f.x === quadX * QUAD_SIZE && f.y === quadY * QUAD_SIZE);\n      if(!existingQuad) {\n        let g = new GearField(context, quadX * QUAD_SIZE, quadY * QUAD_SIZE, QUAD_SIZE, QUAD_SIZE);\n        gearFields.push(g);\n        g.generate();\n      }\n    }\n  }\n\n  let primaryBox = primaryGearContainer.getBoundingClientRect();\n  PRIMARY_GEAR_SIZE = primaryBox.width;\n\n  gearFields.forEach(field => {\n    field.draw(0, 0);\n  });\n\n  primaryGearCanvas.width = PRIMARY_GEAR_SIZE;\n  primaryGearCanvas.height = PRIMARY_GEAR_SIZE;\n  primaryGear.x = PRIMARY_GEAR_SIZE / 2;\n  primaryGear.y = PRIMARY_GEAR_SIZE / 2;\n\n  primaryGear.radius = PRIMARY_GEAR_SIZE / 2;\n  primaryGear.draw();\n\n  primaryGearField.drawGear(primaryGear);\n}\n\nsetCanvasToWindowSize();\nwindow.addEventListener(\"resize\", setCanvasToWindowSize);\n\nrequestAnimationFrame(animate);\n\n\n// adjust anchor offset to account for floating header\nfunction scrollToCurrentHash() {\n  let hash = window.location.hash;\n  if(!hash) {\n    return;\n  }\n  let matchingAnchor = document.querySelector(hash);\n  if(matchingAnchor) {\n    let rect = matchingAnchor.getBoundingClientRect();\n    let headerRect = document.querySelector(\"header\").getBoundingClientRect();\n    let targetOffset = window.pageYOffset + rect.top - headerRect.height;\n\n    window.scrollTo(window.pageXOffset, targetOffset);\n  }\n}\n\nwindow.addEventListener(\"load\", scrollToCurrentHash);\nwindow.addEventListener('hashChange', scrollToCurrentHash);"]}